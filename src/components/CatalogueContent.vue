<template>
	<div class="catalogue">
		<div class="entries">
			<div class="cat-table-wrapper">
				<table class="cat-table">
					<tr class="header">
						<th
							:class="{ sort: sortBy == 'title' }"
							@click="sortTable('title')"
							width="64%"
						>
							<div class="column-header">
								Title
								<font-awesome-icon
									icon="caret-down"
									class="sort-icon"
									:class="sortDirection"
								></font-awesome-icon>
							</div>
						</th>
						<th
							:class="{ sort: sortBy == 'author' }"
							@click="sortTable('author')"
							width="26%"
						>
							<div class="column-header">
								Authors
								<font-awesome-icon
									icon="caret-down"
									class="sort-icon"
									:class="sortDirection"
								></font-awesome-icon>
							</div>
						</th>
						<th
							:class="{ sort: sortBy == 'year' }"
							@click="sortTable('year')"
							width="8%"
						>
							<div class="column-header">
								Year
								<font-awesome-icon
									icon="caret-down"
									class="sort-icon"
									:class="sortDirection"
								></font-awesome-icon>
							</div>
						</th>
					</tr>
					<tr v-if="sortedCatalogue.length == 0 && filterSettings">
						<td colspan="3" class="no-entries">
							No entries found
						</td>
					</tr>
					<tr v-else-if="sortedCatalogue.length == 0">
						<td colspan="3" class="no-entries">
							No entries loaded
						</td>
					</tr>
					<tr
						v-for="entry in sortedCatalogue"
						:id="`id-${entry.id}`"
						:key="entry.id"
						:class="{ selected: entry.id == selectedId }"
						@click="selectEntry(entry.id)"
						v-else
					>
						<td class="title">{{ entry.title }}</td>
						<td
							class="authors"
							v-if="!entry.authors || entry.authors.length == 0"
						></td>
						<td
							class="authors"
							v-else-if="entry.authors.length == 1"
						>
							{{ entry.authors[0] }}
						</td>
						<td
							class="authors"
							v-else-if="entry.authors.length == 2"
						>
							{{ entry.authors[0] }} and
							{{ entry.authors[1] }}
						</td>
						<td class="authors" v-else>
							{{ entry.authors[0] }}
							<span class="et-al">et al</span>
						</td>
						<td class="year">{{ entry.year }}</td>
					</tr>
				</table>
			</div>
			<transition name="fade" mode="out-in">
				<CatalogueFilter
					class="filter"
					:tagList="tagList"
					:filterSettings="filterSettings"
					:count="sortedCatalogue.length"
					v-if="showFilter"
					@close="$emit('filterClosed')"
					@setFilter="setFilter"
				></CatalogueFilter>
				<CatalogueEntry
					class="selected-entry"
					:selectedId="selectedId"
					:selectedEntry="selectedEntry"
					:tagList="tagList"
					:filterSettings="filterSettings"
					v-else
				></CatalogueEntry>
			</transition>
		</div>
	</div>
</template>

<script>
import { json } from '../bib/VIEWpoint-json.js'
import CatalogueEntry from './CatalogueEntry.vue'
import CatalogueFilter from './CatalogueFilter.vue'

export default {
	name: 'CatalogueContent',
	components: {
		CatalogueEntry,
		CatalogueFilter
	},
	props: {
		showFilter: Boolean
	},
	data() {
		return {
			tagList: [
				'Surface temperature',
				'Precipitation and flooding',
				'Drought',
				'Water resources',
				'Cyclones and storms',
				'Urban challenges',
				'Cities',
				'Air quality',
				'Human health',
				'Extreme events',
				'Financial Services',
				'Agriculture and food security',
				'Long term risks',
				'Climate',
				'Climate change',
				'Supply chain',
				'Energy'
				//'Food security'
			],
			sortBy: 'year',
			sortDirection: 'desc',
			clickedId: null,
			filterSettings: {}
		}
	},
	computed: {
		catalogue() {
			return [...json]
		},
		sortedCatalogue() {
			let cat = [...this.catalogue]
			if (this.filterSettings.chars) {
				//const searchWords = this.filterSettings.chars.toUpperCase().split(' ')
				const searchParts = this.filterSettings.chars.match(
					/(?:[^\s"']+|['"][^'"]*["'])+/g
				) // splits into phrases if enclosed by single or double quotes and individual words
				const searchWords = searchParts.map(s =>
					s.toUpperCase().replace(/^["'](.+(?=["']$))["']$/, '$1')
				) // removes enclosing single and double quotes
				cat = cat.filter(c => {
					let foundWords = new Set()
					if (
						this.filterSettings.fields.includes('title') &&
						c.title
					) {
						for (let w = 0; w < searchWords.length; w++) {
							if (
								c.title.toUpperCase().indexOf(searchWords[w]) >=
								0
							) {
								foundWords.add(searchWords[w])
								if (this.filterSettings.matches == 'any') {
									return true
								}
							}
						}
					}
					if (
						this.filterSettings.fields.includes('abstract') &&
						c.abstract
					) {
						for (let w = 0; w < searchWords.length; w++) {
							if (
								c.abstract
									.toUpperCase()
									.indexOf(searchWords[w]) >= 0
							) {
								foundWords.add(searchWords[w])
								if (this.filterSettings.matches == 'any') {
									return true
								}
							}
						}
					}
					if (
						this.filterSettings.fields.includes('author') &&
						c.authors
					) {
						for (let w = 0; w < searchWords.length; w++) {
							for (let i = 0; i < c.authors.length; i++) {
								if (
									c.authors[i]
										.toUpperCase()
										.indexOf(searchWords[w]) >= 0
								) {
									foundWords.add(searchWords[w])
									if (this.filterSettings.matches == 'any') {
										return true
									}
								}
							}
						}
					}
					if (
						this.filterSettings.fields.includes('tags') &&
						c.keywords
					) {
						for (let w = 0; w < searchWords.length; w++) {
							for (let i = 0; i < c.keywords.length; i++) {
								if (
									c.keywords[i]
										.toUpperCase()
										.indexOf(searchWords[w]) >= 0
								) {
									foundWords.add(searchWords[w])
									if (this.filterSettings.matches == 'any') {
										return true
									}
								}
							}
						}
					}
					return foundWords.size == searchWords.length // since this.filterSettings.matches == 'all'!
				})
			}
			if (this.filterSettings.themes) {
				cat = cat.filter(c => {
					if (!c.keywords) return false
					const keyMatches = c.keywords.filter(k => {
						return this.filterSettings.themes.includes(
							k.toUpperCase()
						)
					})
					return keyMatches.length > 0
				})
			}
			const sorted = cat.sort((a, b) => {
				if (this.sortBy !== 'title') {
					let aVal, bVal
					if (this.sortBy == 'author') {
						aVal =
							a.authors && a.authors.length > 0
								? a.authors[0].toUpperCase()
								: ''
						bVal =
							b.authors && b.authors.length > 0
								? b.authors[0].toUpperCase()
								: ''
					} else {
						aVal = a.year || 0
						bVal = b.year || 0
					}
					if (aVal < bVal) {
						return this.sortDirection == 'asc' ? -1 : 1
					}
					if (aVal > bVal) {
						return this.sortDirection == 'asc' ? 1 : -1
					}
				}
				if (a.title.toUpperCase() < b.title.toUpperCase()) {
					return (this.sortDirection == 'asc' || this.sortBy !== 'title') ? -1 : 1
				}
				if (a.title.toUpperCase() > b.title.toUpperCase()) {
					return (this.sortDirection == 'asc' || this.sortBy !== 'title') ? 1 : -1
				}
				return 0
			})
			this.$emit('updateCount', sorted.length)
			return sorted
		},
		selectedId() {
			if (this.clickedId) {
				return this.clickedId
			}
			if (this.sortedCatalogue.length > 0) {
				return this.sortedCatalogue[0].id
			}
			return null
		},
		selectedEntry() {
			if (this.selectedId) {
				return this.catalogue.filter(
					entry => entry.id == this.selectedId
				)[0]
			}
			return null
		}
	},
	watch: {
		sortedCatalogue() {
			if (this.clickedId) {
				if (
					this.sortedCatalogue.length == 0 ||
					this.sortedCatalogue.filter(a => a.id == this.clickedId)
						.length == 0
				) {
					this.clickedId = null
				}
			}
			if (this.sortedCatalogue.length == 0 && !this.showFilter) {
				this.$emit('filterOpen')
			}
			if (this.selectedId) {
				this.$nextTick(() => {
					this.scrollRowIntoView()
				})
			}
		}
	},
	methods: {
		sortTable(order) {
			if (order == this.sortBy) {
				this.sortDirection =
					this.sortDirection == 'asc' ? 'desc' : 'asc'
			} else {
				this.sortBy = order
				this.sortDirection = 'asc'
			}
		},
		selectEntry(entry) {
			this.clickedId = entry
			if (this.showFilter) {
				// if clicked on an entry while the filter is open, close it!
				this.$emit('filterClosed')
			}
		},
		setFilter(newFilter) {
			this.filterSettings = newFilter
			//this.$emit('filterClosed') don't auto-close
		},
		/* following is disabled unless specifically requested
		keypress(event) {
			if (this.sortedCatalogue.length == 0) return
			// if using arrow keys to go up and down, then a right-arrow 
			// will close the filter and show the abstract!
			if (event.key == 'ArrowRight' && this.selectedId && this.showFilter) {
				event.preventDefault()
				this.$emit('filterClosed')
				return
			}
			// otherwise handle up and down arrow keys, home and end, 
			// (and possibly letters)
			let clickedId 
			if (
				event.key == 'Home' ||
				(event.key == 'ArrowUp' && event.ctrlKey)
			) {
				event.preventDefault()
				clickedId = this.sortedCatalogue[0].id
			} else if (
				event.key == 'End' ||
				(event.key == 'ArrowDown' && event.ctrlKey)
			) {
				event.preventDefault()
				clickedId = this.sortedCatalogue[
					this.sortedCatalogue.length - 1
				].id
			} else if (event.key == 'ArrowUp') {
				event.preventDefault()
				for (let c = 1; c < this.sortedCatalogue.length; c++) {
					if (this.sortedCatalogue[c].id == this.selectedId) {
						clickedId = this.sortedCatalogue[c - 1].id
						break
					}
				}
			} else if (event.key == 'ArrowDown') {
				event.preventDefault()
				for (let c = 0; c < this.sortedCatalogue.length - 1; c++) {
					if (this.sortedCatalogue[c].id == this.selectedId) {
						clickedId = this.sortedCatalogue[c + 1].id
						break
					}
				}
			// If cursor's not in the input box for the filter, the following works
			// for title or author sort orders only (nonsensical when in year order) 
			} else if (
				event.key.length == 1 &&
				event.key.match('[a-zA-Z0-9]') &&
				event.target.tagName !== 'INPUT'
			) {
				const matchChar = event.key.toUpperCase()
				const matchingCatalogue = this.sortedCatalogue.filter(c => {
					let firstChar = ''
					if (this.sortBy == 'title' && c.title) {
						firstChar = c.title.substring(0, 1).toUpperCase()
					} else if (this.sortBy == 'author' && c.authors.length > 0) {
						firstChar = c.authors[0].substring(0, 1).toUpperCase()
					}
					return firstChar && firstChar.match('[a-zA-Z0-9]') && firstChar == matchChar
				})
				if (matchingCatalogue.length > 0) {
					clickedId = matchingCatalogue[0].id
				}
			}
			if (clickedId) {
				this.clickedId = clickedId
				this.$nextTick(() => {
					this.scrollRowIntoView()
				})
			}
		},*/
		scrollRowIntoView() {
			// scroll the row into view if required - by changing the table sort order or filter
			// (if keypress gets uncommented - also moving the cursor using a keypress)
			if (!this.selectedId) return
			const el = document.getElementById(`id-${this.selectedId}`)
			if (el) {
				if (typeof el.scrollIntoViewIfNeeded == 'function') {
					el.scrollIntoViewIfNeeded(false) // not FireFox or EdgeHTML - and not smooth behaviour!
				} else {
					const FF = (typeof el.scrollTo == 'function')
					const elBounds = el.getBoundingClientRect()
					const ctr = el.parentElement.parentElement // the scrollable div.cat-table-wrapper
					const ctrBounds = ctr.getBoundingClientRect()
					const offset = 41 // height of sticky header row
					if (elBounds.top < (ctrBounds.top + offset)) {
						if (FF) {
							ctr.scrollTo({ top: el.offsetTop - offset, behavior: 'smooth'})
						} else {
							ctr.scrollTop = el.offsetTop - offset
						}
					}
					if ((elBounds.bottom) > ctrBounds.bottom) {
						if (FF) {
							el.scrollIntoView({behavior: "smooth", block: "end"})
						} else { // testing for scrollTo to pick up EdgeHTML
							el.scrollIntoView(false)
						}
					}
				}
			}
		}
	},
	mounted() {
		//document.addEventListener('keydown', this.keypress)
	},
	beforeDestroy() {
		//document.removeEventListener('keydown', this.keypress)
	}
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
.entries {
	display: flex;
	flex-direction: row;
}

.cat-table-wrapper {
	width: var(--leftPanelWidth);
	height: var(--contentHeight);
	overflow-x: hidden;
	overflow-y: scroll;
}

.cat-table th {
	padding: 8px 16px;
	cursor: pointer;
	position: sticky;
	top: 2px;
	background: var(--vpDark);
	color: var(--whiteDisabled);
	font-weight: normal;
	text-align: left;
	vertical-align: center;
}
.cat-table th.sort {
	color: var(--whiteDefault);
}
.cat-table th:not(.sort):hover {
	color: var(--whiteHover);
}

.column-header {
	display: flex;
	flex-direction: row;
	justify-content: space-between;
	background: transparent;
	color: inherit;
}

.sort-icon {
	margin-left: 4px;
	background: transparent;
	color: transparent;
}
.sort-icon path {
	color: currentColor;
}
th.sort .sort-icon {
	color: var(--whiteDefault);
}
.sort-icon {
	transition: transform 0.2s linear;
}
.sort-icon.desc {
	transform: rotate(180deg);
}

.cat-table tr {
	vertical-align: top;
}

.cat-table tr:nth-of-type(even) td {
	background: var(--primaryLightest);
}
.cat-table tr:nth-of-type(odd) td {
	border-color: var(--primaryLightest);
}

.cat-table td {
	padding: 8px 16px;
	cursor: pointer;
}

.cat-table tr:hover td {
	background: var(--vpPeach);
	border-color: var(--vpCoolGrey);
}

.cat-table tr.selected td {
	background: var(--primaryDisabled);
	border-color: var(--vpCoolGrey);
}

.cat-table td.no-entries {
	text-align: center;
}

.cat-table tr:hover td.no-entries {
	background: var(--primaryLightest);
}

.et-al {
	font-style: italic;
	background: transparent;
}

.fade-enter-active {
	transition: all 0.5s ease-out;
}
.fade-leave-active {
	transition: all 0.3s ease-out;
}
.fade-enter,
.fade-leave-to {
	height: 0;
	opacity: 0;
}

@media (max-width: 640px) {
	img#logo {
		padding-left: 12px;
	}
	.cat-table th,
	.cat-table td {
		padding: 8px 4px;
	}
}
</style>
